{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-acb42c31b7d6e1e19c49dceaeb74e59a9aff5b3b",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/BotsAttack.sol": "project/contracts/BotsAttack.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/BotsAttack.sol": {
        "content": "// SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.28;\n\ncontract BotsAttack {\n    uint8 constant BOARD_SIZE = 5;\n    uint8 constant BOT_COUNT = 5;\n    uint8 constant EMPTY = 0;\n    uint8 constant BOT = 1;\n    uint8 constant INFECTED = 2;\n    uint8 constant MISS = 3;\n\n    struct Score {\n        address player;\n        uint256 totalWins;\n    }\n\n    struct Game {\n        address player1;\n        address player2;\n        uint8[BOARD_SIZE][BOARD_SIZE] player1Board;\n        uint8[BOARD_SIZE][BOARD_SIZE] player2Board;\n        uint8[BOARD_SIZE][BOARD_SIZE] player1Hacks;\n        uint8[BOARD_SIZE][BOARD_SIZE] player2Hacks;\n        bool player1Ready;\n        bool player2Ready;\n        bool gameOver;\n        address winner;\n        uint8 player1BotsRemaining;\n        uint8 player2BotsRemaining;\n        uint256 lastMoveTime;\n        bool player1Turn;\n    }\n\n    uint8[BOARD_SIZE][BOARD_SIZE] EMPTY_BOARD = [\n        [0, 0, 0, 0, 0],\n        [0, 0, 0, 0, 0],\n        [0, 0, 0, 0, 0],\n        [0, 0, 0, 0, 0],\n        [0, 0, 0, 0, 0]\n    ];\n\n    // Mapping of game ID to game state\n    mapping(uint256 => Game) private games;\n    // Counter for game IDs\n    uint256 private gameCounter;\n    // Mapping of player addresses to game IDs\n    mapping(address => uint256[]) private playerGames;\n\n    // Array to store top scores\n    Score[] public topScores;\n    uint256 private constant MAX_TOP_SCORES = 10;\n\n    // Mapping of player address to their personal best score\n    mapping(address => uint256) public playerWins;\n\n    // Events\n    event GameCreated(uint256 gameId, address player1);\n    event PlayerJoined(uint256 gameId, address player2);\n    event BotsPlaced(uint256 gameId, address player);\n    event HackAttempt(\n        uint256 gameId,\n        address player,\n        uint8 x,\n        uint8 y,\n        bool hit\n    );\n    event GameOver(uint256 gameId, address winner);\n\n    // Modifiers\n    modifier validGame(uint256 gameId) {\n        require(gameId <= gameCounter, \"Invalid game ID\");\n        _;\n    }\n\n    modifier playersTurn(uint256 gameId) {\n        Game storage game = games[gameId];\n        require(\n            msg.sender == game.player1 || msg.sender == game.player2,\n            \"Not a player in this game\"\n        );\n        require(!game.gameOver, \"Game is over\");\n        require(\n            (msg.sender == game.player1 && game.player1Turn) ||\n                (msg.sender == game.player2 && !game.player1Turn) ||\n                (!game.player1Ready || !game.player2Ready),\n            \"Not your turn\"\n        );\n        _;\n    }\n\n    function startGame() external returns (uint256) {\n        bool isFirstGame = games[gameCounter].player1 == address(0);\n        bool isLastGameOpen = games[gameCounter].player2 == address(0);\n\n        uint256[] memory existingGames = getPlayerGames(msg.sender);\n        if (existingGames.length > 0) {\n            uint256 existingGame = existingGames[existingGames.length - 1];\n            Game memory lastGame = games[existingGame];\n            if (lastGame.player1 != address(0)) {\n                require(\n                    lastGame.gameOver == true,\n                    \"existing game is still active\"\n                );\n            }\n        }\n\n        if (isFirstGame || !isLastGameOpen) {\n            gameCounter++;\n            Game memory newGame = Game({\n                player1: msg.sender,\n                player2: address(0),\n                player1Board: EMPTY_BOARD,\n                player2Board: EMPTY_BOARD,\n                player1Hacks: EMPTY_BOARD,\n                player2Hacks: EMPTY_BOARD,\n                player1Ready: false,\n                player2Ready: false,\n                gameOver: false,\n                winner: address(0),\n                player1BotsRemaining: BOT_COUNT,\n                player2BotsRemaining: BOT_COUNT,\n                lastMoveTime: block.timestamp,\n                player1Turn: true\n            });\n            games[gameCounter] = newGame;\n            playerGames[msg.sender].push(gameCounter);\n            emit GameCreated(gameCounter, msg.sender);\n        } else {\n            games[gameCounter].player2 = msg.sender;\n            playerGames[msg.sender].push(gameCounter);\n            emit PlayerJoined(gameCounter, msg.sender);\n        }\n\n        return gameCounter;\n    }\n\n    // Place bots on the board\n    function placeBots(\n        uint256 gameId,\n        uint8[BOARD_SIZE][BOARD_SIZE] calldata botLocations\n    ) external validGame(gameId) playersTurn(gameId) {\n        Game storage game = games[gameId];\n        require(\n            !game.player1Ready || !game.player2Ready,\n            \"Bots already placed\"\n        );\n\n        bool isPlayer1 = msg.sender == game.player1;\n\n        uint8[BOARD_SIZE][BOARD_SIZE] storage board = isPlayer1\n            ? game.player1Board\n            : game.player2Board;\n\n        uint8 botCount = 0;\n        // Set the player's board\n        for (uint8 i = 0; i < BOARD_SIZE; i++) {\n            for (uint8 j = 0; j < BOARD_SIZE; j++) {\n                require(\n                    board[i][j] == EMPTY || board[i][j] == BOT,\n                    \"Invalid board\"\n                );\n\n                board[i][j] = botLocations[i][j];\n                if (board[i][j] == BOT) {\n                    botCount++;\n                }\n            }\n        }\n\n        require(botCount == BOT_COUNT, \"Invalid number of bots\");\n\n        if (isPlayer1) {\n            game.player1Ready = true;\n        } else {\n            game.player2Ready = true;\n        }\n\n        game.lastMoveTime = block.timestamp;\n\n        emit BotsPlaced(gameId, msg.sender);\n    }\n\n    // Try hacking a bot on the opponent's bots\n    function tryHackingBot(\n        uint256 gameId,\n        uint8 x,\n        uint8 y\n    ) external validGame(gameId) playersTurn(gameId) {\n        Game storage game = games[gameId];\n        require(\n            game.player1Ready && game.player2Ready,\n            \"Both players must place bots\"\n        );\n        require(x < BOARD_SIZE && y < BOARD_SIZE, \"Invalid coordinates\");\n\n        bool isPlayer1 = msg.sender == game.player1;\n        uint8[BOARD_SIZE][BOARD_SIZE] storage targetBoard = isPlayer1\n            ? game.player2Board\n            : game.player1Board;\n        uint8[BOARD_SIZE][BOARD_SIZE] storage hacksBoard = isPlayer1\n            ? game.player1Hacks\n            : game.player2Hacks;\n\n        require(hacksBoard[x][y] == EMPTY, \"Position already hacked\");\n\n        bool isHit = targetBoard[x][y] == BOT;\n        hacksBoard[x][y] = isHit ? INFECTED : MISS;\n        targetBoard[x][y] = isHit ? INFECTED : MISS;\n\n        if (isHit) {\n            if (isPlayer1) {\n                game.player2BotsRemaining--;\n                if (game.player2BotsRemaining == 0) {\n                    game.gameOver = true;\n                    game.winner = game.player1;\n                    _submitScore(game.winner);\n                    emit GameOver(gameId, game.winner);\n                }\n            } else {\n                game.player1BotsRemaining--;\n                if (game.player1BotsRemaining == 0) {\n                    game.gameOver = true;\n                    game.winner = game.player2;\n                    _submitScore(game.winner);\n                    emit GameOver(gameId, game.winner);\n                }\n            }\n        }\n\n        game.lastMoveTime = block.timestamp;\n        game.player1Turn = !game.player1Turn;\n        emit HackAttempt(gameId, msg.sender, x, y, isHit);\n    }\n\n    // Get the public game state\n    function getGameState(\n        uint256 gameId\n    )\n        external\n        view\n        validGame(gameId)\n        returns (\n            address player1,\n            address player2,\n            bool player1Ready,\n            bool player2Ready,\n            bool gameOver,\n            address winner,\n            uint8 player1BotsRemaining,\n            uint8 player2BotsRemaining,\n            uint256 lastMoveTime,\n            bool player1Turn\n        )\n    {\n        Game storage game = games[gameId];\n\n        return (\n            game.player1,\n            game.player2,\n            game.player1Ready,\n            game.player2Ready,\n            game.gameOver,\n            game.winner,\n            game.player1BotsRemaining,\n            game.player2BotsRemaining,\n            game.lastMoveTime,\n            game.player1Turn\n        );\n    }\n\n    // Get the player boards\n    // includes the initial locations they set,\n    // the hacks they've made\n    // and the hack the opponent made\n    function getPlayerBoards(\n        uint256 gameId\n    )\n        external\n        view\n        validGame(gameId)\n        returns (\n            uint8[BOARD_SIZE][BOARD_SIZE] memory,\n            uint8[BOARD_SIZE][BOARD_SIZE] memory\n        )\n    {\n        Game storage game = games[gameId];\n        require(\n            msg.sender == game.player1 || msg.sender == game.player2,\n            \"Not a player in this game\"\n        );\n        return\n            msg.sender == game.player1\n                ? (game.player1Board, game.player1Hacks)\n                : (game.player2Board, game.player2Hacks);\n    }\n\n    // get player games\n    function getPlayerGames(\n        address player\n    ) public view returns (uint256[] memory) {\n        return playerGames[player];\n    }\n\n    // cancels a game where the last move was more than 20 minutes ago\n    // last player to make a move forfeits\n    function cancelInactiveGame(uint256 gameId) external validGame(gameId) {\n        Game storage game = games[gameId];\n        require(game.player2 != address(0), \"no player 2\");\n        require(game.gameOver == false, \"game is already over\");\n        require(game.player1Ready || game.player2Ready, \"neither board is set\");\n        // check if more than 20 minutes has passed\n        require(\n            block.timestamp >= game.lastMoveTime + 20 minutes,\n            \"20 minutes have not passed\"\n        );\n        // last player to play wins\n        game.gameOver = true;\n        if (game.player1Turn) {\n            game.winner = game.player2;\n            emit GameOver(gameId, game.player2);\n        } else {\n            game.winner = game.player1;\n            emit GameOver(gameId, game.player1);\n        }\n        _submitScore(game.winner);\n    }\n\n    function _submitScore(address _player) internal {\n        playerWins[_player]++;\n\n        // Create new score\n        Score memory newScore = Score({\n            player: _player,\n            totalWins: playerWins[_player]\n        });\n\n        // Update top scores\n        _updateTopScores(newScore);\n    }\n\n    // returns true if score1 is higher than score2\n    function _isScoreHigher(\n        Score memory score1,\n        Score memory score2\n    ) internal pure returns (bool) {\n        if (score1.totalWins == 0) return false; // Handle empty scores\n        if (score2.totalWins == 0) return true; // Handle empty scores\n\n        if (score1.totalWins > score2.totalWins) {\n            return true;\n        }\n        return false;\n    }\n\n    function _updateTopScores(Score memory newScore) internal {\n        // First, remove any existing entry for this player\n        uint256 existingIndex = topScores.length; // Use length as \"not found\" marker\n        for (uint256 i = 0; i < topScores.length; i++) {\n            if (topScores[i].player == newScore.player) {\n                existingIndex = i;\n                break;\n            }\n        }\n\n        // Remove existing entry if found\n        if (existingIndex < topScores.length) {\n            for (uint256 i = existingIndex; i < topScores.length - 1; i++) {\n                topScores[i] = topScores[i + 1];\n            }\n            topScores.pop();\n        }\n\n        // Find where the new score should be inserted\n        uint256 insertIndex = topScores.length;\n        for (uint256 i = 0; i < topScores.length; i++) {\n            if (!_isScoreHigher(topScores[i], newScore)) {\n                insertIndex = i;\n                break;\n            }\n        }\n\n        // If the score qualifies for top scores\n        if (insertIndex < MAX_TOP_SCORES) {\n            // If not at capacity, extend the array\n            if (topScores.length < MAX_TOP_SCORES) {\n                topScores.push(newScore);\n            }\n\n            // Shift existing scores down\n            for (uint256 i = topScores.length - 1; i > insertIndex; i--) {\n                topScores[i] = topScores[i - 1];\n            }\n\n            // Insert the new score\n            topScores[insertIndex] = newScore;\n        }\n    }\n\n    function getTopScores() external view returns (Score[] memory) {\n        return topScores;\n    }\n\n    function getPlayerWins(address _player) external view returns (uint256) {\n        return playerWins[_player];\n    }\n}\n"
      }
    }
  }
}