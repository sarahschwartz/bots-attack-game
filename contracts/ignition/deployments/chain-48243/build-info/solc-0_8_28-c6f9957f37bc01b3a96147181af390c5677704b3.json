{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-c6f9957f37bc01b3a96147181af390c5677704b3",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/BotsAttack.sol": "project/contracts/BotsAttack.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/BotsAttack.sol": {
        "content": "// SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.28;\n\ncontract BotsAttack {\n    uint8 constant BOARD_SIZE = 5;\n    uint8 constant BOT_COUNT = 5;\n    uint8 constant EMPTY = 0;\n    uint8 constant BOT = 1;\n    uint8 constant INFECTED = 2;\n    uint8 constant MISS = 3;\n\n    struct Game {\n        address player1;\n        address player2;\n        uint8[BOARD_SIZE][BOARD_SIZE] player1Board;\n        uint8[BOARD_SIZE][BOARD_SIZE] player2Board;\n        uint8[BOARD_SIZE][BOARD_SIZE] player1Hacks;\n        uint8[BOARD_SIZE][BOARD_SIZE] player2Hacks;\n        bool player1Ready;\n        bool player2Ready;\n        bool gameOver;\n        address winner;\n        uint8 player1BotsRemaining;\n        uint8 player2BotsRemaining;\n        uint256 lastMoveTime;\n        bool player1Turn;\n    }\n\n    uint8[BOARD_SIZE][BOARD_SIZE] EMPTY_BOARD = [\n        [0, 0, 0, 0, 0],\n        [0, 0, 0, 0, 0],\n        [0, 0, 0, 0, 0],\n        [0, 0, 0, 0, 0],\n        [0, 0, 0, 0, 0]\n    ];\n\n    // Mapping of game ID to game state\n    mapping(uint256 => Game) private games;\n    // Counter for game IDs\n    uint256 private gameCounter;\n    // Mapping of player addresses to game IDs\n    mapping(address => uint256[]) private playerGames;\n\n    // Events\n    event GameCreated(uint256 gameId, address player1);\n    event PlayerJoined(uint256 gameId, address player2);\n    event BotsPlaced(uint256 gameId, address player);\n    event HackAttempt(\n        uint256 gameId,\n        address player,\n        uint8 x,\n        uint8 y,\n        bool hit\n    );\n    event GameOver(uint256 gameId, address winner);\n\n    // Modifiers\n    modifier validGame(uint256 gameId) {\n        require(gameId <= gameCounter, \"Invalid game ID\");\n        _;\n    }\n\n    modifier playersTurn(uint256 gameId) {\n        Game storage game = games[gameId];\n        require(\n            msg.sender == game.player1 || msg.sender == game.player2,\n            \"Not a player in this game\"\n        );\n        require(!game.gameOver, \"Game is over\");\n        require(\n            (msg.sender == game.player1 && game.player1Turn) ||\n                (msg.sender == game.player2 && !game.player1Turn) ||\n                (!game.player1Ready || !game.player2Ready),\n            \"Not your turn\"\n        );\n        _;\n    }\n\n    function startGame() external returns (uint256) {\n        bool isFirstGame = games[gameCounter].player1 == address(0);\n        bool isLastGameOpen = games[gameCounter].player2 == address(0);\n\n        uint256[] memory existingGames = getPlayerGames(msg.sender);\n        if (existingGames.length > 0) {\n            uint256 existingGame = existingGames[existingGames.length - 1];\n            Game memory lastGame = games[existingGame];\n            if (lastGame.player1 != address(0)) {\n                require(\n                    lastGame.gameOver == true,\n                    \"existing game is still active\"\n                );\n            }\n        }\n\n        if (isFirstGame || !isLastGameOpen) {\n            gameCounter++;\n            Game memory newGame = Game({\n                player1: msg.sender,\n                player2: address(0),\n                player1Board: EMPTY_BOARD,\n                player2Board: EMPTY_BOARD,\n                player1Hacks: EMPTY_BOARD,\n                player2Hacks: EMPTY_BOARD,\n                player1Ready: false,\n                player2Ready: false,\n                gameOver: false,\n                winner: address(0),\n                player1BotsRemaining: BOT_COUNT,\n                player2BotsRemaining: BOT_COUNT,\n                lastMoveTime: block.timestamp,\n                player1Turn: true\n            });\n            games[gameCounter] = newGame;\n            playerGames[msg.sender].push(gameCounter);\n            emit GameCreated(gameCounter, msg.sender);\n        } else {\n            games[gameCounter].player2 = msg.sender;\n            playerGames[msg.sender].push(gameCounter);\n            emit PlayerJoined(gameCounter, msg.sender);\n        }\n\n        return gameCounter;\n    }\n\n    // Place bots on the board\n    function placeBots(\n        uint256 gameId,\n        uint8[BOARD_SIZE][BOARD_SIZE] calldata botLocations\n    ) external validGame(gameId) playersTurn(gameId) {\n        Game storage game = games[gameId];\n        require(\n            !game.player1Ready || !game.player2Ready,\n            \"Bots already placed\"\n        );\n\n        bool isPlayer1 = msg.sender == game.player1;\n\n        uint8[BOARD_SIZE][BOARD_SIZE] storage board = isPlayer1\n            ? game.player1Board\n            : game.player2Board;\n\n        uint8 botCount = 0;\n        // Set the player's board\n        for (uint8 i = 0; i < BOARD_SIZE; i++) {\n            for (uint8 j = 0; j < BOARD_SIZE; j++) {\n                require(\n                    board[i][j] == EMPTY || board[i][j] == BOT,\n                    \"Invalid board\"\n                );\n\n                board[i][j] = botLocations[i][j];\n                if (board[i][j] == BOT) {\n                    botCount++;\n                }\n            }\n        }\n\n        require(botCount == BOT_COUNT, \"Invalid number of bots\");\n\n        if (isPlayer1) {\n            game.player1Ready = true;\n        } else {\n            game.player2Ready = true;\n        }\n\n        game.lastMoveTime = block.timestamp;\n\n        emit BotsPlaced(gameId, msg.sender);\n    }\n\n    // Try hacking a bot on the opponent's bots\n    function tryHackingBot(\n        uint256 gameId,\n        uint8 x,\n        uint8 y\n    ) external validGame(gameId) playersTurn(gameId) {\n        Game storage game = games[gameId];\n        require(\n            game.player1Ready && game.player2Ready,\n            \"Both players must place bots\"\n        );\n        require(x < BOARD_SIZE && y < BOARD_SIZE, \"Invalid coordinates\");\n\n        bool isPlayer1 = msg.sender == game.player1;\n        uint8[BOARD_SIZE][BOARD_SIZE] storage targetBoard = isPlayer1\n            ? game.player2Board\n            : game.player1Board;\n        uint8[BOARD_SIZE][BOARD_SIZE] storage hacksBoard = isPlayer1\n            ? game.player1Hacks\n            : game.player2Hacks;\n\n        require(hacksBoard[x][y] == EMPTY, \"Position already hacked\");\n\n        bool isHit = targetBoard[x][y] == BOT;\n        hacksBoard[x][y] = isHit ? INFECTED : MISS;\n        targetBoard[x][y] = isHit ? INFECTED : MISS;\n\n        if (isHit) {\n            if (isPlayer1) {\n                game.player2BotsRemaining--;\n                if (game.player2BotsRemaining == 0) {\n                    game.gameOver = true;\n                    game.winner = game.player1;\n                    emit GameOver(gameId, game.player1);\n                }\n            } else {\n                game.player1BotsRemaining--;\n                if (game.player1BotsRemaining == 0) {\n                    game.gameOver = true;\n                    game.winner = game.player2;\n                    emit GameOver(gameId, game.player2);\n                }\n            }\n        }\n\n        game.lastMoveTime = block.timestamp;\n        game.player1Turn = !game.player1Turn;\n        emit HackAttempt(gameId, msg.sender, x, y, isHit);\n    }\n\n    // Get the public game state\n    function getGameState(\n        uint256 gameId\n    )\n        external\n        view\n        validGame(gameId)\n        returns (\n            address player1,\n            address player2,\n            bool player1Ready,\n            bool player2Ready,\n            bool gameOver,\n            address winner,\n            uint8 player1BotsRemaining,\n            uint8 player2BotsRemaining,\n            uint256 lastMoveTime,\n            bool player1Turn\n        )\n    {\n        Game storage game = games[gameId];\n\n        return (\n            game.player1,\n            game.player2,\n            game.player1Ready,\n            game.player2Ready,\n            game.gameOver,\n            game.winner,\n            game.player1BotsRemaining,\n            game.player2BotsRemaining,\n            game.lastMoveTime,\n            game.player1Turn\n        );\n    }\n\n    // Get the player boards\n    // includes the initial locations they set,\n    // the hacks they've made\n    // and the hack the opponent made\n    function getPlayerBoards(\n        uint256 gameId\n    )\n        external\n        view\n        validGame(gameId)\n        returns (\n            uint8[BOARD_SIZE][BOARD_SIZE] memory,\n            uint8[BOARD_SIZE][BOARD_SIZE] memory\n        )\n    {\n        Game storage game = games[gameId];\n        require(\n            msg.sender == game.player1 || msg.sender == game.player2,\n            \"Not a player in this game\"\n        );\n        return\n            msg.sender == game.player1\n                ? (game.player1Board, game.player1Hacks)\n                : (game.player2Board, game.player2Hacks);\n    }\n\n    // get player games\n    function getPlayerGames(\n        address player\n    ) public view returns (uint256[] memory) {\n        return playerGames[player];\n    }\n\n    // cancels a game where the last move was more than 1 day ago\n    function cancelInactiveGame(uint256 gameId) validGame(gameId) external {\n        Game storage game = games[gameId];\n        require(game.player2 != address(0), \"no player 2\");\n        require(game.gameOver == false, \"game is already over\");\n        // check if more than 1 day has passed\n        require(\n            block.timestamp >= game.lastMoveTime + 1 days,\n            \"1 day has not passed\"\n        );\n        // last player to play wins\n        game.gameOver = true;\n        if (game.player1Turn) {\n            game.winner = game.player2;\n            emit GameOver(gameId, game.player2);\n        } else {\n            game.winner = game.player1;\n            emit GameOver(gameId, game.player1);\n        }\n    }\n}\n"
      }
    }
  }
}